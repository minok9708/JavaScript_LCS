<!-- 모든 변수는 let이나 const 사용 var 금지 -->
<!-- 모든 함수는 화살표함수를 사용 이유는 화살표 함수 사용시 콜백함수 표기를 단순하게 할수 있고
this바인딩을 하지않아도 됨 -->
<!-- 메소드를 화살표 함수로 정의하면 함수 내부의 this는 window 객체를 가리키기 때문에 문제가 발생함 -->
<!-- 이벤트리스너는 () => 이렇게하지말고 function()으로 해야함 -->
<!--  https://poiemaweb.com/es6-arrow-function -->
<!-- 이런 경우엔 다음과 같이 ES6의 축약 메소드를 사용하는 것이 좋음 -->

<!-- @@@@@@@@ before 일반 화살표함수 사용 @@@@@@@@-->
<!-- const marine = {
    action: 'attack',
    operation: () => { <--------- 차이점
        console.log(this.action); // undefined
    }
};
marine.operation(); -->

<!-- @@@@@@@@ after 축약메소드 사용 @@@@@@@@-->
<!-- const marine = {
  action: 'attack',
  operation() { <------- 여기를 보면됨
      console.log(this.action); // attack
  }
};
marine.operation(); -->

<!-- 화살표함수 설명 링크 : https://freestrokes.tistory.com/103 -->
<!-- 1. 맵 객체 생성 -->
<!-- 2. 현재위치 사용가능하면 현재위치를 받아와서 마커 표시후 시점변환 -->
<!-- 3. 초기경계위치를 바탕으로 현재화면안에있는 마커데이터만 수신 -->
<!-- 4. 3번에서 받아온 마커데이터를 바탕으로 화면에 표시 -->
<!-- 5. 사용자가 화면을 옮기는 이벤트를 수행할때 마다 그에 맞게 화면에 마커 표시 -->
<!-- 6. 마커마다 커스텀 오버레이를 활용하여 사용자가 마커를 클릭하는 이벤트를 수행했을시 Adobe XD 오버레이디자인에 맞게 출력 -->
<!-- 7. 사용자는 마커를 눌러 오버레이를 보고 오버레이에 상세정보 버튼을 눌러 상세정보 페이지로 데이터와 함께 이동 -->
<!DOCTYPE html>
<!-- 화면 꽉차게 height: 100% -->
<html lang="en" style="height: 100%">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
    />

    <!-- 타이틀바 이름 -->
    <title>지도</title>

    <!-- 카카오맵을 사용하기 위한 Api호출 -->
    <script
      type="text/javascript"
      src="//dapi.kakao.com/v2/maps/sdk.js?appkey=50dd95b7d54ebee9819b8e4a4a52081f&libraries=services,clusterer"
    ></script>

    <!-- 서버가 안될시 임시 샘플 마커 데이터 -->
    <script type="text/javascript" src="../com/js/markerData.js"></script>

    <!-- Axios 라이브러리를 사용하기 위한 Api호출 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.0/axios.min.js"></script>

    <!-- 커스텀윈도우 디자인을 사용하기 위한 호출 -->
    <!--  <script type="text/javascript" src="/com/js"></script> -->

    <!-- 외부 css파일 사용 -->
    <link href="/com/css/map.css" rel="stylesheet" type="text/css" />

    <!-- 검색 아이콘 -->
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.6.1/css/all.css"
      type="text/css"
    />

    <!-- width 768px밑으로 넘어가면 모바일 css가 적용됨 -->
    <link
      rel="stylesheet"
      media="screen and (max-width: 768px)"
      href="/com/css/mobile_map.css"
      type="text/css"
    />
    <!-- 테스트 -->
  </head>

  <!-- Map.Html Body -->
  <body class="map_page_body">
    <!-- 지도위에 검색바 기능 -->

    <form id="searchBar" onsubmit="return false">
      <input
        id="search_Box"
        type="text"
        placeholder="검색어를 입력하세요"
        name="search"
        onkeypress="enterSearch()"
      />

      <button
        id="search_Btn"
        type="button"
        value="검색"
        onclick="searchPlaces()"
      >
        <i class="fa fa-search"></i>
      </button>
    </form>
    <!-- 맵 출력 -->
    <div id="map"></div>
    <!-- 모바일 커스텀 오버레이 -->
    <div id="content_box">
      <div id="content_box_title">제목</div>
      <div id="content_box_close_btn" img src="#"></div>
      <div id="content_box_addr">주소</div>
      <div id="content_box_phone">번호</div>
      <div id="test_box">
        <!-- <div id="content_box_floorNumber">층</div> -->
        <div id="content_box_useSeatCnt">사용중인 테이블</div>
        <div id="content_box_devide"></div>
        <div id="content_box_totalSeatCnt">총 테이블</div>
        <button id="content_box_btn">상세정보</button>
      </div>
    </div>
    <script>
      let casheData = [];
      //  컨테이너에 div 값을 가져오는 코드

      // function receive_get_data(param) {
      //   let result = null;
      //   let tmp = [];
      //   let items = window.location.search.substring(1).split("&");
      //   console.log(window.location);
      //   console.log(window.location.search);
      //   for (var i = 0; i < items.length; i++) {
      //     tmp = items[i].split("=");
      //     if (tmp[0] === param) result = decodeURIComponent(tmp[1]);
      //   }
      //   return result;
      // }

      /* let temp;
      let data = [];
      temp = location.href.split("?");
      //console.log(`temp값:${temp}`);
      test = temp[1].split("&");
      //console.log(`test값:${test}`);

      keyword = test[0].split("=");
      //console.log(`keyword 값: ${keyword[1]}`);
      keyword = keyword[1];
      //console.log(keyword);

      check = test[1].split("=");
      //console.log(`check 값: ${check[1]}`);
      check = check[1];
      //console.log(check); */

      const container = document.getElementById("map");
      // 맵 초기기본옵션 설정
      const options = {
        center: new kakao.maps.LatLng(37.5906981, 127.0739813),
        level: 3,
        draggable: true,
      };
      // 카카오맵 컨테이너 인자값과 옵션인자값을 주고 생성
      let map = new kakao.maps.Map(container, options);

      let clusterer = new kakao.maps.MarkerClusterer({
        map: map, // 마커들을 클러스터로 관리하고 표시할 지도 객체
        averageCenter: true, // 클러스터에 포함된 마커들의 평균 위치를 클러스터 마커 위치로 설정
        minLevel: 8, // 클러스터 할 최소 지도 레벨
      });

      // 지도 줌인 레벨 조정
      map.setMinLevel(3);
      // 지도 줌아웃 레벨 조정
      map.setMaxLevel(10);
      // 지도에 확대 축소 컨트롤을 생성
      let zoomControl = new kakao.maps.ZoomControl();
      // 지도의 우측에 확대 축소 컨트롤을 추가
      map.addControl(zoomControl, kakao.maps.ControlPosition.RIGHT);
      //위에 객체가 실행후 0.1초후에 실행
      setTimeout(() => {
        /*  if (check === "true") {
          //console.log("검색바로 검색햇을때 서버로 데이터 요청");

          let searchUrl = "https://cafeaddy.xyz:8080/api/cafes/name/cafeName=";

          axios({
            url: searchUrl + keyword,
            method: "get",
          })
            .then((data) => {
              console.log(data.data.data);
              getSearchMarkerInfo(data.data.data);
            })
            .catch((error) => {
              console.log(error.response);
            });
        } else if (check === "false") {
          
        } */
        findLocation();
        searchPlaces();
      }, 100);

      // 키보드로 엔터를 눌럿을때
      function enterSearch() {
        if (event.keyCode === 13) {
          searchPlaces(); // 실행할 이벤트
        }
      }

      /* getSearchMarkerInfo = (keywordList) => {
        //console.log(keywordList);
        console.log("실행되지?");
        keywordList.map((value, index) => {
          let contenta =
            '<div class="wrap">' +
            '    <div class="info">' +
            '        <div class="title">' +
            value.name +
            "        </div>" +
            '        <div class="body">' +
            '            <div class="desc">' +
            '                <div class="addr">' +
            "" +
            value.parcelAddr +
            "</div>" +
            '                <div class="phone">' +
            "" +
            value.phone +
            "</div>" +
            '                <div class="overlay">' +
            '                <div class="sit">' +
            value.seatInfos[0].useSeatCnt +
            "</div>" +
            '                <div class="divide">' +
            "/" +
            "</div>" +
            '                <div class="sit_full">' +
            value.seatInfos[0].totalSeatCnt +
            "</div>" +
            "                </div>" +
            '                <button class="info_btn" ' +
            'onclick="' +
            "location.href='/search/cafe_info.html'" +
            '"' +
            "> " +
            "상세정보" +
            "</button>" +
            "            </>" +
            "        </div>" +
            "    </div>" +
            "</div>";
          // ----------------------------------------------------- 마커 객체 생성 부분 시작 ------------------------------------------------
          let imageSrc = "http://maps.google.com/mapfiles/ms/icons/red.png", // 마커이미지의 주소입니다
            imageSize = new kakao.maps.Size(32, 32); // 마커이미지의 크기입니다

          let markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);

          let keywordMarker = new kakao.maps.Marker({
            map: map,
            position: new kakao.maps.LatLng(value.latitude, value.longitude),
            // 마커 아이콘 이미지
            // image: markerImage,
            title: value.name,
          });

          kakao.maps.event.addListener(keywordMarker, "click", function () {
            console.log("마커를 클릭");
            customOverlayA.setMap(map);
          });

          let customOverlayA = new kakao.maps.CustomOverlay({
            position: keywordMarker.getPosition(),
            content: contenta,
            clickable: true,
            zindex: 9999,
          });

          kakao.maps.event.addListener(map, "click", function () {
            console.log("맵을 클릭");
            customOverlayA.setMap(null);
          });
        });
      };
 */
      // 장소 검색 객체를 생성합니다
      let ps = new kakao.maps.services.Places();

      const findLocation = () => {
        // 현위치 마커 표시
        // HTML5의 geolocation으로 사용할 수 있는지 확인
        console.log("현위치");
        if (navigator.geolocation) {
          // GeoLocation을 이용해서 접속 위치를 얻어오는것
          navigator.geolocation.getCurrentPosition((position) => {
            let lat = position.coords.latitude, // 현위치 위도
              lon = position.coords.longitude; // 현위치 경도
            //console.log(lat);
            //console.log(lon);

            let locPosition = new kakao.maps.LatLng(lat, lon); // 마커가 표시될 위치를 geolocation으로 얻어온 좌표로 생성
            // 변수안에 html을 표현할때 변수를 넣고자 하면 +를 사용 하여 스트링과 분리하여 자바처럼 변수를 넣으면됨
            // 반복문일 경우 lat[i] lon[i] title[i] 이런식으로 사용가능
            // message =
            //   '<div style="padding:25px;">' +
            //   "경도: " +
            //   lat +
            //   "<br>" +
            //   "위도: " +
            //   lon +
            //   "</div>"; // 인포윈도우에 표시될 내용

            // 마커와 인포윈도우를 표시
            displayMarker(locPosition);
            console.log("현위치 불러옴");
          });
        } else {
          // HTML5의 GeoLocation을 사용할 수 없을때 디폴트 마커 표시 위치와 인포윈도우 내용을 설정
          let locPosition = new kakao.maps.LatLng(33.450701, 126.570667),
            message = "geolocation을 사용할수 없어요..";
          displayMarker(locPosition);
        }
        {
          //옵션
          enableHighAccuracy = true; //베터리를 소모해서 더 정확한 위치를 찾음
          maximumAge = 0; //한번찾은 위치정보를 해당 초만큼 캐싱
          timeout = Infinity; //주어진 초에 찾지못하면 에러발생
        }
      };

      // 지도에 마커와 인포윈도우를 표시하는 함수
      const displayMarker = (locPosition) => {
        // 현위치 마커 이미지 변경
        let imageSrc =
            "https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png", // 마커이미지의 주소입니다
          imageSize = new kakao.maps.Size(64, 69), // 마커이미지의 크기입니다
          imageOption = {offset: new kakao.maps.Point(27, 69)}; // 마커이미지의 옵션입니다. 마커의 좌표와 일치시킬 이미지 안에서의 좌표를 설정합니다.

        let markerImage = new kakao.maps.MarkerImage(
          imageSrc,
          imageSize,
          imageOption
        );

        // 마커 생성
        let marker = new kakao.maps.Marker({
          map: map,
          position: locPosition,
          image: markerImage,
        });

        // 지도 중심좌표를 접속위치로 시점 변환으로 변경
        // setCenter 함수로도 할수있음 하지만 시점변환을 부드럽게 하고자 하기위해 panTo사용
        map.panTo(locPosition);
      };

      //키워드로 장소 겁색
      // 키워드 검색을 요청하는 함수입니다
      function searchPlaces() {
        let keyword = document.getElementById("search_Box").value;
        console.log(keyword);
        // if (!keyword.replace(/^\s+|\s+$/g, "")) {
        //   alert("키워드를 입력해주세요!");
        //   return false;
        // }

        // 장소검색 객체를 통해 키워드로 장소검색을 요청합니다
        ps.keywordSearch(keyword, placesSearchCB);
      }

      // 장소검색이 완료됐을 때 호출되는 콜백함수 입니다
      function placesSearchCB(data, status, pagination) {
        if (status === kakao.maps.services.Status.OK) {
          // 정상적으로 검색이 완료됐으면
          console.log("장소검색 완료");
          displayPlaces(data);
        } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
          alert("검색 결과가 존재하지 않습니다.");
          return;
        } else if (status === kakao.maps.services.Status.ERROR) {
          alert("검색 결과 중 오류가 발생했습니다.");
          return;
        }
      }

      // 검색 결과 목록과 마커를 표출하는 함수입니다
      function displayPlaces(places) {
        bounds = new kakao.maps.LatLngBounds();

        for (let i = 0; i < places.length; i++) {
          // 마커를 생성하고 지도에 표시합니다
          let placePosition = new kakao.maps.LatLng(places[i].y, places[i].x);
          // 검색된 장소 위치를 기준으로 지도 범위를 재설정하기위해
          // LatLngBounds 객체에 좌표를 추가합니다
          bounds.extend(placePosition);
        }
        // 검색된 장소 위치를 기준으로 지도 범위를 재설정합니다
        map.panTo(bounds);
      }

      //----------------------------------------------------------------------------------------------------------------------------------

      // 지도가 이동, 확대, 축소로 인해 지도영역이 변경되면 마지막 파라미터로 넘어온 함수를 호출하도록 이벤트를 등록
      // 화살표 함수 사용
      // 여기다가 뭘 넣어야할지 의문
      // 아예 필요없을수도 idle이 대체
      // const bounds_change = kakao.maps.event.addListener(
      //   map,
      //   "bounds_changed",
      //   () => {}
      // );

      // 지도 시점이 완전히 변화했을때 수행되는 이벤트 등록
      // boundsChange와 다름
      // https://code-zzolbo.tistory.com/33
      const map_idle = kakao.maps.event.addListener(map, "idle", function () {
        // 리스너는 동기 안에있는 통신코드는 비동기 : 아직 통신이 끝나지 않은상태에서 마커를 그리려하면 오류가남 그래서 promise를 사용해서
        // 비동기인 방식을 동기식으로 바꿔줘야함
        // 동기 실행순서 : A B C 가 있으면 A -> B -> C
        // 비동기 실행순서 : A B C 가 있으면 B -> A -> C , A -> C -> B 이런식으로 순서가 뒤죽박죽

        // 지도 영역정보를 얻어오기
        let bounds = map.getBounds();

        // 영역정보의 남서쪽 정보 얻어오기
        let swLatlng = bounds.getSouthWest();

        // 영역정보의 북동쪽 정보 얻어오기
        let neLatlng = bounds.getNorthEast();

        // 영역정보의 남서쪽 위도, 경도값 변수
        let swLatitude = swLatlng.getLat();
        let swLongitude = swLatlng.getLng();
        // 영역정보의 북동쪽 위도, 경도값 변수
        let neLatitude = neLatlng.getLat();
        let neLongitude = neLatlng.getLng();

        let message =
          "지도의 중심좌표는 " +
          map.getCenter().toString() +
          " 입니다." +
          "\n" +
          "확대 레벨은 " +
          map.getLevel() +
          " 레벨 입니다.";
        // console.log(message);

        //idle 이벤트가 끝날때마다 getCafeInfo함수로 경계값 데이터를 보냄
        if (check === "false") {
          getCafeInfo(neLongitude, neLatitude, swLongitude, swLatitude);
        }
      });

      //------------------------------------------------------------------------
      //커스텀 오버레이 하나만 열리게 하기 위한 클릭 변수
      let clickedOverlay = null;
      //---------------------------------------------------------------------------

      // getCafeInfo : 받은 데이터를 가지고 서버와 통신을해 데이터를 받는 함수
      const getCafeInfo = (ne1, ne2, sw1, sw2) => {
        //   통신코드는 비동기이기 때문에 동기로 바꿔주기 위하여 프로미스를 사용
        //   프로미스의 목적은 어지간한게 비동기적으로 돌아가는 자바스크립트에서 순차적실행을 위하여 사용
        return new Promise((res, reject) => {
          // 마커데이터 불러오는 통신코드
          let mapUrl = "https://cafeaddy.xyz:8080/api/cafes/around";
          axios({
            method: "get",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            url: mapUrl,
            data: {},
            params: {
              neLongitude: ne1,
              neLatitude: ne2,
              swLongitude: sw1,
              swLatitude: sw2,
            },
          })
            .then(({data}) => {
              //성공적으로 통신이 완료되면 reslove -> res 함수를 사용해 getCafeSyncInfo함수로 매개변수(데이터)로 전달
              // res(getCafeSyncInfo((cafeData = data.data)));
              // casheData = data.data;
              // res(removeDuplicatesArray(casheData));
              res(getCafeSyncInfo(data.data));
            })
            .catch((error) => {
              console.log("error:", error.response);
              //실패하면 reject("에러처리 함수로 보내거나 텍스트")
              // alert("데이터가 없습니다.");
              reject("실패");
            });
        });
      };

      // // 배열 중복요소 제거 함수
      // function removeDuplicatesArray(arr) {
      //   let tempArr = [];
      //   for (let i = 0; i < arr.length; i++) {
      //     if (tempArr.length == 0) {
      //       tempArr.push(arr[i]);
      //     } else {
      //       let duplicatesFlag = true;
      //       for (let j = 0; j < tempArr.length; j++) {
      //         if (tempArr[j] == arr[i]) {
      //           duplicatesFlag = false;
      //           break;
      //         }
      //       }
      //       if (duplicatesFlag) {
      //         tempArr.push(arr[i]);
      //       }
      //     }
      //   }
      //   getCafeSyncInfoTrue(tempArr);
      // }

      // getCafeSyncInfo 함수는 위에서 보내온 데이터를 받아서 다시 bbb함수로 전달
      getCafeSyncInfo = (cafeData) => {
        return new Promise((res, reject) => {
          if (cafeData) {
            //console.log("마커데이터가 받아진것같습니다.");
            //console.log(cafeData);
            res(getCafeSyncInfoTrue(cafeData));
          } else {
            reject(console.log("아직 데이터가 완전히 받아지지 않았음"));
          }
        });
      };
      //getCafeSyncInfo함수가 참(트루) 그러니깐 완벽히 수행이 되었을때 getCafeSyncInfoTrue함수로 보내온 데이터를 바탕으로 맵함수를 사용해서 마커를 생성
      getCafeSyncInfo(true).then(
        (getCafeSyncInfoTrue = (cafe) => {
          console.log(cafe.seatInfos);
          let markers = [];
          const event = null;
          // 클러스터 초기화
          clusterer.clear();
          cafe.map((marker, index) => {
            let content =
              '<div class="wrap">' +
              '    <div class="info">' +
              '        <div class="title">' +
              marker.name +
              "        </div>" +
              '        <div class="body">' +
              '            <div class="desc">' +
              '                <div class="addr">' +
              "" +
              marker.parcelAddr +
              "</div>" +
              '                <div class="phone">' +
              "" +
              marker.phone +
              "</div>" +
              '                <div class="overlay">' +
              '                <div class="sit">' +
              marker.seatInfos[0].useSeatCnt +
              "</div>" +
              '                <div class="divide">' +
              "/" +
              "</div>" +
              '                <div class="sit_full">' +
              marker.seatInfos[0].totalSeatCnt +
              "</div>" +
              "                </div>" +
              '                <button class="info_btn" ' +
              'onclick="' +
              "location.href='/search/cafe_info.html'" +
              '"' +
              "> " +
              "상세정보" +
              "</button>" +
              "            </>" +
              "        </div>" +
              "    </div>" +
              "</div>";

            // 서버에서 얻어온 마커에 아이콘 변경
            let imageSrc = "http://maps.google.com/mapfiles/ms/icons/red.png", // 마커이미지의 주소입니다
              imageSize = new kakao.maps.Size(32, 32); // 마커이미지의 크기입니다

            let markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize);

            let m = new kakao.maps.Marker({
              map: map,
              position: new kakao.maps.LatLng(
                marker.latitude,
                marker.longitude
              ),
              // 마커 아이콘 이미지
              // image: markerImage,
              title: marker.name,
            });
            // 클러스터 사용위한 push
            markers.push(m);

            let minWidth = 768;
            if (minWidth >= window.outerWidth) {
              console.log(window.outerWidth);
              //마커 클릭시 이벤트 처리
              kakao.maps.event.addListener(m, "click", function () {
                document.getElementById("content_box").style.visibility =
                  "visible";
                document.getElementById("content_box_title").innerHTML =
                  marker.name;
                document.getElementById("content_box_addr").innerHTML =
                  marker.parcelAddr;
                document.getElementById("content_box_phone").innerHTML =
                  marker.phone;
                // document.getElementById("content_box_floorNumber").innerHTML =
                //   marker.seatInfos[0].floorNumber + "층";
                document.getElementById("content_box_useSeatCnt").innerHTML =
                  marker.seatInfos[0].useSeatCnt + "&nbsp";
                document.getElementById("content_box_devide").innerHTML =
                  "/" + "&nbsp";
                document.getElementById("content_box_totalSeatCnt").innerHTML =
                  marker.seatInfos[0].totalSeatCnt;
              });

              kakao.maps.event.addListener(map, "click", function () {
                document.getElementById("content_box").style.visibility =
                  "hidden";
              });
            } else {
              // 커스텀 오버레이를 생성합니다

              let customOverlay = new kakao.maps.CustomOverlay({
                position: m.getPosition(),
                content: content,
                clickable: true,
                zindex: 3,
              });

              //마커 클릭시 이벤트 처리
              kakao.maps.event.addListener(m, "click", function () {
                console.log(marker);
                console.log(marker.seatInfos[0].totalSeatCnt);
                // 커스텀 오버레이 z-index 값 설정
                customOverlay.setZIndex(3);
                if (clickedOverlay) {
                  //console.log("null이 아닐때");
                  clickedOverlay.setMap(null);
                }
                customOverlay.setMap(map);
                // 커스텀 오버레이의 z-index값 파악
                console.log(customOverlay.getZIndex());
                clickedOverlay = customOverlay;
              });

              kakao.maps.event.addListener(map, "click", function () {
                customOverlay.setMap(null);
              });
            }

            // 커스텀 오버레이를 지도에 표시합니다
            // customOverlay.setMap(map);
          });
          // 클러스터에 마커 추가
          clusterer.addMarkers(markers);

          // markes배열에 계속 푸쉬가 되는 현상 방지를 위한 배열 초기화
          // markers.length = 0;

          // console.log(markers);
          // console.log(markers.length);
        })
      );
    </script>
  </body>
</html>
