<!-- 모든 변수는 let이나 const 사용 var 금지 -->
<!-- 모든 함수는 화살표함수를 사용 이유는 화살표 함수 사용시 콜백함수 표기를 단순하게 할수 있고
this바인딩을 하지않아도 됨 -->
<!-- 메소드를 화살표 함수로 정의하면 함수 내부의 this는 window 객체를 가리키기 때문에 문제가 발생함 -->
<!-- 이벤트리스너는 () => 이렇게하지말고 function()으로 해야함 -->
<!--  https://poiemaweb.com/es6-arrow-function -->
<!-- 이런 경우엔 다음과 같이 ES6의 축약 메소드를 사용하는 것이 좋음 -->

<!-- @@@@@@@@ before 일반 화살표함수 사용 @@@@@@@@-->
<!-- const marine = {
    action: 'attack',
    operation: () => { <--------- 차이점
        console.log(this.action); // undefined
    }
};
marine.operation(); -->

<!-- @@@@@@@@ after 축약메소드 사용 @@@@@@@@-->
<!-- const marine = {
  action: 'attack',
  operation() { <------- 여기를 보면됨
      console.log(this.action); // attack
  }
};
marine.operation(); -->

<!-- 화살표함수 설명 링크 : https://freestrokes.tistory.com/103 -->
<!-- 1. 맵 객체 생성 -->
<!-- 2. 현재위치 사용가능하면 현재위치를 받아와서 마커 표시후 시점변환 -->
<!-- 3. 초기경계위치를 바탕으로 현재화면안에있는 마커데이터만 수신 -->
<!-- 4. 3번에서 받아온 마커데이터를 바탕으로 화면에 표시 -->
<!-- 5. 사용자가 화면을 옮기는 이벤트를 수행할때 마다 그에 맞게 화면에 마커 표시 -->
<!-- 6. 마커마다 커스텀 오버레이를 활용하여 사용자가 마커를 클릭하는 이벤트를 수행했을시 Adobe XD 오버레이디자인에 맞게 출력 -->
<!-- 7. 사용자는 마커를 눌러 오버레이를 보고 오버레이에 상세정보 버튼을 눌러 상세정보 페이지로 데이터와 함께 이동 -->
<!DOCTYPE html>
<!-- 화면 꽉차게 height: 100% -->
<html lang="en" style="height: 100%">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
    />

    <!-- 타이틀바 이름 -->
    <title>지도</title>

    <!-- 카카오맵을 사용하기 위한 Api호출 -->
    <script
      type="text/javascript"
      src="//dapi.kakao.com/v2/maps/sdk.js?appkey=f47e84cf13db3f58d6f37bcb23b2f9a4&libraries=services"
    ></script>

    <!-- 서버가 안될시 임시 샘플 마커 데이터 -->
    <script type="text/javascript" src="./markerData.js"></script>

    <!-- Axios 라이브러리를 사용하기 위한 Api호출 -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.0/axios.min.js"></script> -->

    <!-- 외부 css파일 사용 -->
    <link href="Map.css" rel="stylesheet" type="text/css" />
  </head>

  <!-- Map.Html Body -->
  <body class="map_page_body">
    <!-- 지도위에 검색바 기능 -->
    <form id="searchBar">
      <input
        id="selectMain"
        type="text"
        placeholder="검색어를 입력하세요"
        name="search"
        onkeydown="enterSearch()"
      />
      <input
        id="searchMain"
        type="button"
        value="검색"
        onclick="myFunction()"
      />
    </form>
<<<<<<< HEAD
    <!-- 맵 출력 -->
    <div id="map"></div>
=======
    
    <!-- 맵 출력 -->
    <div id="map"></div>
    
>>>>>>> fb8ed53dc543af496765e539fd0d84964b5b0636
    <script>
      // 마커데이터를 담을 배열
      // 서버통신을 통하여 여기에다가 담으면됨
      // let markerdata = [];
      var markers = [];
      var cafeData = [];
      // 이게 아마 그 리액트에서 썻던 window 맵객체 공유하는거 document.getElementById가 중요
      const container = document.getElementById("map");
      // 맵 초기기본옵션 설정
      const options = {
        center: new kakao.maps.LatLng(37.5906981, 127.0739813),
        level: 3,
        draggable: true,
      };
      // 카카오맵 컨테이너 인자값과 옵션인자값을 주고 생성
      let map = new kakao.maps.Map(container, options);
      // 지도 줌인 레벨 조정
      map.setMinLevel(3);
      // 지도 줌아웃 레벨 조정
      map.setMaxLevel(10);
      // 지도에 확대 축소 컨트롤을 생성
      let zoomControl = new kakao.maps.ZoomControl();
      // 지도의 우측에 확대 축소 컨트롤을 추가
      map.addControl(zoomControl, kakao.maps.ControlPosition.RIGHT);

      // 위에 객체가 실행후 0.1초후에 실행
      setTimeout(() => {
        findLocation();
      }, 100);
      //---------------------------------------------------------------------------------------------------------------------------------
      // 키보드로 엔터를 눌럿을때
      function enterSearch() {
        if (event.keyCode == 13) {
          myFunction(); // 실행할 이벤트
        }
      }

      //검색바에 검색한 키워드를 콘솔에 출력
      function myFunction() {
        var keyword = document.getElementById("selectMain").value;
        console.log(keyword);

        let searchMessage = '"' + keyword + '"' + " 에 대한 검색결과 입니다";
        console.log(searchMessage);
        //alert(keyword)

        let searchUrl = "http://cafeaddy.xyz:8080/api/name";

        /*  axios
          .post(searchUrl, {
            name: keyword,
          })
          .then((data) => {
            console.log(data);
          })
          .catch((error) => {
            console.log("error!!!!");
          }); */
      }

      //--------------------------------------------------------------------------------------------------------------------------------------------------

      const findLocation = () => {
        // 현위치 마커 표시
        // HTML5의 geolocation으로 사용할 수 있는지 확인
        if (navigator.geolocation) {
          // GeoLocation을 이용해서 접속 위치를 얻어오는것
          navigator.geolocation.getCurrentPosition((position) => {
            let lat = position.coords.latitude, // 현위치 위도
              lon = position.coords.longitude; // 현위치 경도
            console.log(lat);
            console.log(lon);

            let locPosition = new kakao.maps.LatLng(lat, lon), // 마커가 표시될 위치를 geolocation으로 얻어온 좌표로 생성
              // 변수안에 html을 표현할때 변수를 넣고자 하면 +를 사용 하여 스트링과 분리하여 자바처럼 변수를 넣으면됨
              // 반복문일 경우 lat[i] lon[i] title[i] 이런식으로 사용가능
              message =
                '<div style="padding:25px;">' +
                "경도: " +
                lat +
                "<br>" +
                "위도: " +
                lon +
                "</div>"; // 인포윈도우에 표시될 내용

            // 마커와 인포윈도우를 표시
            displayMarker(locPosition, message);
          });
        } else {
          // HTML5의 GeoLocation을 사용할 수 없을때 디폴트 마커 표시 위치와 인포윈도우 내용을 설정
          let locPosition = new kakao.maps.LatLng(33.450701, 126.570667),
            message = "geolocation을 사용할수 없어요..";

          displayMarker(locPosition, message);
        }
        {
          //옵션
          enableHighAccuracy = true; //베터리를 소모해서 더 정확한 위치를 찾음
          maximumAge = 0; //한번찾은 위치정보를 해당 초만큼 캐싱
          timeout = Infinity; //주어진 초에 찾지못하면 에러발생
        }
      };

      // 지도에 마커와 인포윈도우를 표시하는 함수
      const displayMarker = (locPosition, message) => {
        // 마커 생성
        let marker = new kakao.maps.Marker({
          map: map,
          position: locPosition,
        });

        let iwContent = message, // 인포윈도우에 표시할 내용
          // 삭제버튼 표시 논리값 변수 false 시 인포윈도우 닫는 X 표시 사라짐
          iwRemoveable = true;

        // 인포윈도우를 생성
        let infowindow = new kakao.maps.InfoWindow({
          content: iwContent,
          removable: iwRemoveable,
        });

        // 인포윈도우를 마커위에 표시
        infowindow.open(map, marker);

        // 지도 중심좌표를 접속위치로 시점 변환으로 변경
        // setCenter 함수로도 할수있음 하지만 시점변환을 부드럽게 하고자 하기위해 panTo사용
        map.panTo(locPosition);
      };

      // 지도가 이동, 확대, 축소로 인해 지도영역이 변경되면 마지막 파라미터로 넘어온 함수를 호출하도록 이벤트를 등록
      // 화살표 함수 사용
      // 여기다가 뭘 넣어야할지 의문
      // 아예 필요없을수도 idle이 대체
      // const bounds_change = kakao.maps.event.addListener(
      //   map,
      //   "bounds_changed",
      //   () => {}
      // );

      // 지도 시점이 완전히 변화했을때 수행되는 이벤트 등록
      // boundsChange와 다름
      // https://code-zzolbo.tistory.com/33
      const map_idle = kakao.maps.event.addListener(map, "idle", function () {
        // 리스너는 동기 안에있는 통신코드는 비동기 : 아직 통신이 끝나지 않은상태에서 마커를 그리려하면 오류가남 그래서 promise를 사용해서
        // 비동기인 방식을 동기식으로 바꿔줘야함
        // 동기 실행순서 : A B C 가 있으면 A -> B -> C
        // 비동기 실행순서 : A B C 가 있으면 B -> A -> C , A -> C -> B 이런식으로 순서가 뒤죽박죽

        // 지도 영역정보를 얻어오기
        let bounds = map.getBounds();

        // 영역정보의 남서쪽 정보 얻어오기
        let swLatlng = bounds.getSouthWest();

        // 영역정보의 북동쪽 정보 얻어오기
        let neLatlng = bounds.getNorthEast();

        // 영역정보의 남서쪽 위도, 경도값 변수
        let swLatitude = swLatlng.getLat();
        let swLongitude = swLatlng.getLng();
        // 영역정보의 북동쪽 위도, 경도값 변수
        let neLatitude = neLatlng.getLat();
        let neLongitude = neLatlng.getLng();

        let message =
          "지도의 중심좌표는 " +
          map.getCenter().toString() +
          " 입니다." +
          "\n" +
          "확대 레벨은 " +
          map.getLevel() +
          " 레벨 입니다.";
        console.log(message);

        // idle 이벤트가 끝날때마다 getCafeInfo함수로 경계값 데이터를 보냄
        // getCafeInfo(neLongitude, neLatitude, swLongitude, swLatitude);
      });

      //// getCafeInfo : 받은 데이터를 가지고 서버와 통신을해 데이터를 받는 함수
      // const getCafeInfo = (ne1, ne2, sw1, sw2) => {
      ////   통신코드는 비동기이기 때문에 동기로 바꿔주기 위하여 프로미스를 사용
      ////   프로미스의 목적은 어지간한게 비동기적으로 돌아가는 자바스크립트에서 순차적실행을 위하여 사용
      //   return new Promise((res, reject) => {
      //     마커데이터 불러오는 통신코드
      //      let mapUrl = "https://cafeaddy.xyz:8080/api/cafes/around";
      //     axios({
      //       method: "get",
      //       headers: {
      //         "Content-Type": "application/json",
      //         Accept: "application/json",
      //       },
      //       url: mapUrl,
      //       data: {},
      //       params: {
      //         neLongitude: ne1,
      //         neLatitude: ne2,
      //         swLongitude: sw1,
      //         swLatitude: sw2,
      //       },
      //     })
      //       .then(({data}) => {
      //         성공적으로 통신이 완료되면 reslove -> res 함수를 사용해 aaa함수로 매개변수(데이터)로 전달
      //         res(aaa((cafeData = data.data)));
      //       })
      //       .catch((error) => {
      //         console.log("error:", error.response);
      //         실패하면 reject("에러처리 함수로 보내거나 텍스트")
      //         reject("실패");
      //       });
      //   });
      // };

      // aaa 함수는 위에서 보내온 데이터를 받아서 다시 bbb함수로 전달
      // aaa = (cafeData) => {
      //   return new Promise((res, reject) => {
      //     if (cafeData) {
      //       console.log("마커데이터가 받아진것같습니다.");
      //       console.log(cafeData);
      //       res(bbb(cafeData));
      //     } else {
      //       reject(ddd);
      //     }
      //   });
      // };

      // aaa함수가 참(트루) 그러니깐 완벽히 수행이 되었을때 bbb함수로 보내온 데이터를 바탕으로 맵함수를 사용해서 마커를 생성
      // aaa(true).then(
      //   (bbb = (cafe) => {
      //     cafe.map((marker, index) => {
      //       console.log(index);
      //       console.log(marker);
      //       console.log(marker.name);

      //       console.log(marker.latitude);
      //       console.log(marker.longitude);

      //       let m = new kakao.maps.Marker({
      //         map: map,
      //         position: new kakao.maps.LatLng(
      //           marker.latitude,
      //           marker.longitude
      //         ),
      //       });
      //     });
      //   }),
      //   (ccc = () => {
      //     console.log("진짜 실패함");
      //   })
      // );

      // ddd = () => {
      //   console.log("ddd가 실패했다.");
      // };

      const markerDisplay = markerdata.map((marker) => {
        console.log(marker);
        var content =
          '<div class ="infowindow"><label>카페이름: </label><br><label>주소:</lable></div>';

        let ma = new kakao.maps.Marker({
          map: map,
          key: marker.id,
          position: new kakao.maps.LatLng(marker.lat, marker.lng),
          title: marker.name,
        });

        // 커스텀 오버레이를 생성합니다
        var customOverlay = new kakao.maps.CustomOverlay({
          position: new kakao.maps.LatLng(marker.lat, marker.lng),
          content: content,
        });

        // 커스텀 오버레이를 지도에 표시합니다
        customOverlay.setMap(map);
      });
    </script>
  </body>
</html>
